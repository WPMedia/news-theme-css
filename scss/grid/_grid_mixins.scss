//Private variables, do not modify.  Grid mixins will update these by globalizing when necessary.
$ms-col-gap: null;
$ms-row-gap: null;
$ms-col-count: null;
$ms-row-count: null;

@function repeat($iterationCount, $val: 1fr) {
  $res: ();
  @for $i from 1 through $iterationCount {
    $res: append($res, $val, space);
  }
  @return $res;
}

@mixin grid-column-start($spanNum) {
  -ms-grid-column: span #{$spanNum};
  grid-column-start: span #{$spanNum};
  @content;
}

@mixin grid-column($start: auto, $span: 1) {
  //  apply fake grid gap via margin for browsers that don't support grid-column-gap
  @if $ms-col-gap and not $ms-col-count and $start != 1 {
    margin-left: $ms-col-gap;
    @supports (grid-column-gap: 1px) { margin-left: 0; }
  }
  -ms-grid-column: if($ms-col-count, $start + $start - 1, $start);
  grid-column: span #{$span};
  -ms-grid-column-span: if($ms-col-count, $span + $span - 1, $span);
  @content;
}

@mixin grid-row($start: auto, $span: 1) {
  //  grid-row-gap using top margin
  @if $ms-row-gap and not $ms-row-count and $start != 1 {
    margin-top: $ms-row-gap;
    @supports (grid-row-gap: 1px) { margin-top: 0; }
  }
  -ms-grid-row: if($ms-row-count, $start + $start - 1, $start);
  grid-row: #{$start}/#{$start + $span};
  -ms-grid-row-span: if($ms-row-count, $span + $span - 1, $span);
  @content;
}

@mixin grid-cell($col-start: auto, $col-span: 1, $row-start: auto, $row-span: 1) {
  @include grid-column($col-start, $col-span);
  @include grid-row($row-start, $row-span);
  @content;
}

@mixin grid-area($area) {
  $area: map-get($grid-areas, $area);
  @include grid-column(nth($area, 1), nth($area, 2));
  @include grid-row(nth($area, 3), nth($area, 4));
  @content;
}

@mixin grid($grid-map) {
  //'gap' is the global gap - if col-gap and row-gap are in the map
  //then it uses those, if it doesn't then it looks for 'gap';

  $cols: map-get($grid-map, cols);
  $rows: map-get($grid-map, rows);
  $gap: map-get($grid-map, gap);

  $col-gap: map-get($grid-map, col-gap);
  $col-gap: if($col-gap, $col-gap, $gap);

  $row-gap: map-get($grid-map, row-gap);
  $row-gap: if($row-gap, $row-gap, $gap);

  //  if cols or rows have one paramter and unitless, convert them to FR units
  @if $cols and length($cols) == 1 and unitless($cols) {
    $cols: repeat($cols);
  }

  @if $rows and length($rows) == 1 and unitless($rows) {
    $rows: repeat($rows);
  }

  //  Internet Explorer does not support grid gap - we have to fake grid gap for IE
  //  with extra grid rows/columns.

  //  the first loop is to ensure cols/rows are not a multidimensional list
  //  (when generated by the repeat function)
  $ms-cols: null;
  $ms-rows: null;

  @if $col-gap and $cols {
    $ms-cols: ();
    @each $col in $cols {
      $ms-cols: if(type-of($col) == list, join($ms-cols, $col), append($ms-cols, $col));
    }
    @for $i from 1 through length($ms-cols) - 1 {
      $ms-cols: set-nth($ms-cols, $i, nth($ms-cols, $i) $col-gap);
    }
    //  globalize ms col count (used by grid-column)
    $ms-col-count: length($ms-cols) !global;
  }

  @if $row-gap and $rows {
    $ms-rows: ();
    @each $row in $rows {
      $ms-rows: if(type-of($row) == list, join($ms-rows, $row), append($ms-rows, $row));
    }
    @for $i from 1 through length($ms-rows) - 1 {
      $ms-rows: set-nth($ms-rows, $i, nth($ms-rows, $i) $row-gap);
    }
    //  globalize ms-row-count (used by grid-row)
    $ms-row-count: length($ms-rows) !global;
  }

  $ms-col-gap: $col-gap !global;
  $ms-row-gap: $row-gap !global;

  display: -ms-grid;
  display: grid;

  grid-column-gap: $col-gap;

  -ms-grid-columns: $ms-cols or $cols;
  grid-row-gap: $row-gap;
  -ms-grid-rows: $ms-rows or $rows;

  grid-template-columns: $cols;
  grid-template-rows: $rows;
  @content;
}
